<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java基础知识"><meta name="keywords" content="Java,设计模式"><meta name="author" content="董兰天"><meta name="copyright" content="董兰天"><title>Java基础知识 | 董兰天的江湖路</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-多线程"><span class="toc-text">1.多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#（1）voliatile和synchonized有什么区别？"><span class="toc-text">（1）voliatile和synchonized有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（2）synchonized和jdk提供的Lock包有什么区别？"><span class="toc-text">（2）synchonized和jdk提供的Lock包有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（-3）线程池"><span class="toc-text">（ 3）线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Java集合"><span class="toc-text">2.Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#（1）HashMap"><span class="toc-text">（1）HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（2）ConcurrentHashMap"><span class="toc-text">（2）ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（3）HashMap和hashtable区别？"><span class="toc-text">（3）HashMap和hashtable区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-异常"><span class="toc-text">3.异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-抽象类和接口"><span class="toc-text">4.抽象类和接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Object方法"><span class="toc-text">5.Object方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-包装类"><span class="toc-text">6.包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-单例模式"><span class="toc-text">1.单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-工厂模式"><span class="toc-text">2.工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-代理模式"><span class="toc-text">3.代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-适配器模式"><span class="toc-text">4.适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-策略模式"><span class="toc-text">5.策略模式</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="images\头像.jpg"></div><div class="author-info__name text-center">董兰天</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(images\背景图片.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">董兰天的江湖路</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">我的主页</a><a class="site-page" href="/categories">文章分类</a><a class="site-page" href="/archives">时间轴</a><a class="site-page" href="/tags">好多标签呀</a></span></div><div id="post-info"><div id="post-title">Java基础知识</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/面试基础知识总结/">面试基础知识总结</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><a href="http://how2j.cn/k/j2se-interview/j2se-interview-java/624.html#" target="_blank" rel="noopener">http://how2j.cn/k/j2se-interview/j2se-interview-java/624.html#</a></p>
<p><a href="https://blog.csdn.net/hope900/article/details/78647466" target="_blank" rel="noopener">https://blog.csdn.net/hope900/article/details/78647466</a></p>
<h2 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h2><h3 id="（1）voliatile和synchonized有什么区别？"><a href="#（1）voliatile和synchonized有什么区别？" class="headerlink" title="（1）voliatile和synchonized有什么区别？"></a>（1）voliatile和synchonized有什么区别？</h3><p><a href="https://www.jianshu.com/p/0fc7ebb8d4f8" target="_blank" rel="noopener">https://www.jianshu.com/p/0fc7ebb8d4f8</a></p>
<ul>
<li>volatile特性：</li>
</ul>
<ol>
<li><p>当一个线程要使用volatile变量时，它会直接从主内存中读取，而不使用自己工作内存中的副本。</p>
<p>当一个线程对一个volatile变量写时，它会将变量的值刷新到共享内存(主内存)中。</p>
</li>
<li><p>禁止指令重新排序优化</p>
</li>
<li><p>不能保证原子性</p>
</li>
</ol>
<ul>
<li><p>synchonized</p>
<p>synchonized是通过上锁来防治出现并发问题。synchronized作用的代码范围对于不同线程是互斥的，并且线程在释放锁的时候会将共享变量的值刷新到共享内存中。</p>
</li>
</ul>
<p><strong>区别</strong>：</p>
<ol>
<li><p>使用：voliatile 用于修饰变量，synchronized可以修饰对象，类，方法，代码块，语句。</p>
</li>
<li><p>原子性：voliatile只保证变量的可见性，不能用于同步变量，即不保证原子性，多线程并发访问voliatile修饰的变量时也不会产生阻塞。synchronized是原子性的，只有锁定了变量的线程才能进入临界区，从而保证临界区的所有语句全部执行。多线程并发访问sychronized修饰的变量会产生阻塞。</p>
</li>
<li><p>机理：</p>
<p>当线程对volatile变量读时，会把工作内存中值置为无效。当线程对sychronized变量读时，会在该线程锁定变量时把工作内存中值置为无效。</p>
<p>当线程对voliatile变量写时，会把值刷新到主内存中。当线程对sychronized变量写时，会在变量解锁时把值刷新到主内存中。</p>
</li>
</ol>
<h3 id="（2）synchonized和jdk提供的Lock包有什么区别？"><a href="#（2）synchonized和jdk提供的Lock包有什么区别？" class="headerlink" title="（2）synchonized和jdk提供的Lock包有什么区别？"></a>（2）synchonized和jdk提供的Lock包有什么区别？</h3><p>​    synchronized是基于jvm底层实现的数据同步，lock是基于Java编写，主要通过硬件依赖CPU指令实现数据同步。与synchronized不同的是lock是纯java手写的，与底层的JVM无关。在java.util.concurrent.locks包中有很多Lock的实现类</p>
<p>​        <strong>1.synchronized</strong></p>
<p>　　优点：实现简单，语义清晰，便于JVM堆栈跟踪，加锁解锁过程由JVM自动控制，提供了多种优化方案，使用更广泛</p>
<p>　　缺点：悲观的排他锁，不能进行高级功能</p>
<p>　　<strong>2.lock</strong></p>
<p>　　优点：可定时的、可轮询的与可中断的锁获取操作，提供了读写锁、公平锁和非公平锁　　</p>
<p>　　缺点：需手动释放锁unlock，不适合JVM进行堆栈跟踪</p>
<p>　　<strong>3.相同点</strong>　</p>
<p>　　都是可重入锁</p>
<p>总结来说，Lock和synchronized有以下几点不同：</p>
<p>　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p>
<p>　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p>
<p>　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p>
<p>　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p>
<p>　　5）Lock可以提高多个线程进行读操作的效率。</p>
<p>　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<h3 id="（-3）线程池"><a href="#（-3）线程池" class="headerlink" title="（ 3）线程池"></a>（ 3）线程池</h3><p>​    为了防止线程频繁的创建撤销所带来的内存消耗。线程池中有一些核心线程永远不会被清理，当有一个任务需要执行时，首先判断线程池中的核心线程是否都在执行，如果没有，则创建一个工作线程执行任务，否则将任务放入等待队列，如果队列已满，则判断线程池（核心线程+非核心线程）是否已经满了，如果未满，则创建非核心线程执行该任务，如果满了就调用拒绝策略来管理任务。</p>
<p><a href="https://blog.csdn.net/weixin_40271838/article/details/79998327" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40271838/article/details/79998327</a></p>
<h2 id="2-Java集合"><a href="#2-Java集合" class="headerlink" title="2.Java集合"></a>2.Java集合</h2><h3 id="（1）HashMap"><a href="#（1）HashMap" class="headerlink" title="（1）HashMap"></a>（1）<strong>HashMap</strong></h3><p><a href="https://www.cnblogs.com/chengxiao/p/6059914.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6059914.html</a></p>
<p><a href="https://segmentfault.com/a/1190000012926722" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012926722</a></p>
<ul>
<li><strong>定义</strong></li>
</ul>
<p>​        HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</p>
<ul>
<li><strong>动态扩容</strong></li>
</ul>
<p>​        当hashmap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16</em>0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置。</p>
<ul>
<li><p><strong>Java8和Java7的区别</strong></p>
<ol>
<li><p>在Java8中当链表过长时使用红黑树保存节点。</p>
</li>
<li><p>Java8扩容时不会重新计算节点的哈希值，因为在计算哈希值时最后会与数组长度取余（与操作来取余），故索引位置要么是原位置，要么是在原位置再移动2次幂的位置，所以无需计算。</p>
</li>
<li><p>Java7中扩容时，索引位置相同的节点会倒置，Java8不会。</p>
</li>
<li><p>Java8中重新定义了Node&lt;K,V&gt;实现了Map.Entry&lt;K,V&gt;</p>
<p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></p>
</li>
</ol>
</li>
</ul>
<p><strong>多线程并发问题</strong>：</p>
<ol>
<li><p>现在假如A线程和B线程同时对同一个数组位置调用addEntry，两个线程会同时得到现在的头结点，然后A写入新的头结点之后，B也写入新的头结点，那B的写入操作就会覆盖A的写入操作造成A的写入操作丢失。</p>
</li>
<li><p>当多个线程同时操作同一个数组位置的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写会到该数组位置去，其实写回的时候可能其他的线程已经就把这个位置给修改过了，就会覆盖其他线程的修改。</p>
</li>
<li><p>当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。</p>
<p>多线程扩容时出现的问题：<a href="https://blog.csdn.net/chisunhuang/article/details/79041656" target="_blank" rel="noopener">https://blog.csdn.net/chisunhuang/article/details/79041656</a></p>
</li>
</ol>
<h3 id="（2）ConcurrentHashMap"><a href="#（2）ConcurrentHashMap" class="headerlink" title="（2）ConcurrentHashMap"></a>（2）ConcurrentHashMap</h3><p>分段锁：容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。</p>
<p>其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。</p>
<p>1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。<br>2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。<br>3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。<br>4.链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。<br>5.查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p>
<h3 id="（3）HashMap和hashtable区别？"><a href="#（3）HashMap和hashtable区别？" class="headerlink" title="（3）HashMap和hashtable区别？"></a>（3）<strong>HashMap和hashtable区别？</strong></h3><p> 1、HashMap是非线程安全的，HashTable是线程安全的。<br> 2、HashMap的键和值都允许有null值存在，而HashTable则不行。<br> 3、因为线程安全的问题，HashMap效率比HashTable的要高。<br> 4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。 </p>
<p>​        一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的ConcurrentHashMap替代，没有必要因为是多线程而用HashTable。     </p>
<h2 id="3-异常"><a href="#3-异常" class="headerlink" title="3.异常"></a>3.异常</h2><p>Throwable又派生出Error类和Exception类。</p>
<p>错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p>
<p>异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。</p>
<p><img src="images\异常.png" alt></p>
<p><strong>非检查异常</strong>（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。</p>
<p><strong>检查异常</strong>（checked exception）：除了Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则==编译不会通过==。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。</p>
<h2 id="4-抽象类和接口"><a href="#4-抽象类和接口" class="headerlink" title="4.抽象类和接口"></a>4.抽象类和接口</h2><ul>
<li>区别</li>
</ul>
<ol>
<li>一个类可以实现多个接口，但只能继承一个抽象类</li>
<li>抽象类可以有默认的方法实现，而在1.8之前，接口不可以有默认的方法实现。1.8中，接口可以为default类型的方法提供默认实现。</li>
<li>抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符，接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符。</li>
<li>抽象类中子类使用<strong>extends</strong>关键字来继承抽象类，如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现；接口中子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现。</li>
<li>抽象类可以有构造方法，接口不能有构造方法。</li>
<li>抽象方法可以有main方法并且我们可以运行它；接口没有main方法，因此我们不能运行它。</li>
</ol>
<h2 id="5-Object方法"><a href="#5-Object方法" class="headerlink" title="5.Object方法"></a>5.Object方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> registerNatives()    <span class="comment">//私有方法</span></span><br><span class="line"> <span class="number">2</span> getClass()          <span class="comment">//返回此 Object 的运行类。</span></span><br><span class="line"> <span class="number">3</span> hashCode()          <span class="comment">//用于获取对象的哈希值。</span></span><br><span class="line"> <span class="number">4</span> equals(Object obj)     <span class="comment">//用于确认两个对象是否“相同”。</span></span><br><span class="line"> <span class="number">5</span> clone()               <span class="comment">//创建并返回此对象的一个副本。 </span></span><br><span class="line"> <span class="number">6</span> toString()           <span class="comment">//返回该对象的字符串表示。   </span></span><br><span class="line"> <span class="number">7</span> notify()            <span class="comment">//唤醒在此对象监视器上等待的单个线程。   </span></span><br><span class="line"> <span class="number">8</span> notifyAll()         <span class="comment">//唤醒在此对象监视器上等待的所有线程。   </span></span><br><span class="line"> <span class="number">9</span> wait(<span class="keyword">long</span> timeout)    <span class="comment">//在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间    量前，导致当前线程等待。   </span></span><br><span class="line"><span class="number">10</span> wait(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)    <span class="comment">//在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其    他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。</span></span><br><span class="line"><span class="number">11</span> wait()    <span class="comment">//用于让当前线程失去操作权限，当前线程进入等待序列</span></span><br><span class="line"><span class="number">12</span> finalize()    <span class="comment">//当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</span></span><br></pre></td></tr></table></figure>
<h2 id="6-包装类"><a href="#6-包装类" class="headerlink" title="6.包装类"></a>6.包装类</h2><p>1.自动装箱、拆箱</p>
<p>2.内部cach</p>
<p>​        Integer和Long类的内部都定义了一个cach用来存放-128到127之间的数，当我们赋值的数在这个区间时，使用的是方法区常量池中缓存数据，因此使用==比较时相等。范围之外的数就会新建一个对象，因此对象地址不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long a=<span class="number">128</span>;</span><br><span class="line">Long b=<span class="number">128</span>;</span><br><span class="line">System.out.println(a==b);<span class="comment">//false</span></span><br><span class="line">Long a=<span class="number">127</span>;</span><br><span class="line">Long b=<span class="number">127</span>;</span><br><span class="line">System.out.println(a==b);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>源码解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">LongCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> Long[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">                cache[i] = <span class="keyword">new</span> Long(i - <span class="number">128</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">            <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><a href="http://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/singleton-pattern.html</a></p>
<p><a href="https://blog.csdn.net/qq_33326449/article/details/78946364" target="_blank" rel="noopener">https://blog.csdn.net/qq_33326449/article/details/78946364</a></p>
<p>共23种，分为三类：创建型（单例模式、工厂模式……）、结构型模式（代理模式、适配器模式……）、行为型模式（策略模式、观察者模式……）</p>
<h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a><strong>1.单例模式</strong></h3><p><strong>简介：</strong></p>
<p>该类只有一个对象被创建，类本身创建自己的对象。</p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<p><strong>实现：</strong></p>
<ol>
<li><p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>懒汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程安全的单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;   </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;    <span class="comment">//对获取实例的方法进行同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)     </span><br><span class="line">          instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>​    上述加锁方式仍然不能保证安全。首先，由于指令会重排序，instance变量有可能再未被初始化的情况下被返回，造成空指针异常；其次，第一次null判断后线程阻塞，另一个线程创建实例后第一个线程再次创建实例造成多个实例被创建，因此，又有了双重校验锁模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;  <span class="comment">//volatile防止指令重排序造成空指针异常</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//双重校验锁：防止在#语句处线程阻塞造成多个实例被创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;              <span class="comment">//#</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a><strong>2.工厂模式</strong></h3><p><strong>简介：</strong></p>
<p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p><strong>实现：</strong></p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/08/factory_pattern_uml_diagram.jpg" alt></p>
<ol>
<li>创建一个接口:</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建实现接口的实体类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Rectangle.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Square.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Square::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Circle.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建一个工厂，生成基于给定信息的实体类的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ShapeFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用该工厂，通过传递类型信息来获取实体类的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FactoryPatternDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">      <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line">      <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line">      <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line">      <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">      shape3.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3.代理模式"></a><strong>3.代理模式</strong></h3><p><strong>简介：</strong></p>
<p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>
<p>意图：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>实现：</strong></p>
<p>在代理类中创建原类的对象，并调用其方法。</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/08/proxy_pattern_uml_diagram.jpg" alt></p>
<ol>
<li><p>创建一个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Image.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建实现接口的实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被代理的类RealImage.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> String fileName;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">      loadFromDisk(fileName);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Displaying "</span> + fileName);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Loading "</span> + fileName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类ProxyImage.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> RealImage realImage;</span><br><span class="line">   <span class="keyword">private</span> String fileName;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(realImage == <span class="keyword">null</span>)&#123;</span><br><span class="line">         realImage = <span class="keyword">new</span> RealImage(fileName);</span><br><span class="line">      &#125;</span><br><span class="line">      realImage.display();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当被请求时，使用 <em>ProxyImage</em> 来获取 <em>RealImage</em> 类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProxyPatternDemo.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPatternDemo</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Image image = <span class="keyword">new</span> ProxyImage(<span class="string">"test_10mb.jpg"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 图像将从磁盘加载   //？不是很懂</span></span><br><span class="line">      image.display(); </span><br><span class="line">      System.out.println(<span class="string">""</span>);</span><br><span class="line">      <span class="comment">// 图像不需要从磁盘加载</span></span><br><span class="line">      image.display();  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-适配器模式"><a href="#4-适配器模式" class="headerlink" title="4.适配器模式"></a><strong>4.适配器模式</strong></h3><p><strong>简介：</strong></p>
<p>​    适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。</p>
<p>意图：将一个类的接口转换成客户希望的另外一个接口。</p>
<p><strong>实现：</strong></p>
<p>Ps2转USB的适配器：我们想让Ps2接口的设备具备USB的功能，于是写一个适配器实现Ps2的接口并集成USB的功能，就可以让Ps2接口的设备跟USB一样，具备USB的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ps2接口：Ps2</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ps2</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="function"><span class="keyword">void</span> <span class="title">isPs2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Ps2接口实现类：Ps2er</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ps2er</span> <span class="keyword">implements</span> <span class="title">Ps2</span> </span>&#123;</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">4</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isPs2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">5</span>         System.out.println(<span class="string">"Ps2口"</span>);</span><br><span class="line"><span class="number">6</span>     &#125;</span><br><span class="line"><span class="number">7</span> </span><br><span class="line"><span class="number">8</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//USB接口：Usb</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Usb</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="function"><span class="keyword">void</span> <span class="title">isUsb</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//USB接口实现类：Usber</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Usber</span> <span class="keyword">implements</span> <span class="title">Usb</span> </span>&#123;</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">4</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isUsb</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">5</span>         System.out.println(<span class="string">"USB口"</span>);</span><br><span class="line"><span class="number">6</span>     &#125;</span><br><span class="line"><span class="number">7</span> </span><br><span class="line"><span class="number">8</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器：Adapter</span></span><br><span class="line"> <span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Ps2</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     </span><br><span class="line"> <span class="number">3</span>     <span class="keyword">private</span> Usb usb;</span><br><span class="line"> <span class="number">4</span>     <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Usb usb)</span></span>&#123;</span><br><span class="line"> <span class="number">5</span>         <span class="keyword">this</span>.usb = usb;</span><br><span class="line"> <span class="number">6</span>     &#125;</span><br><span class="line"> <span class="number">7</span>     <span class="meta">@Override</span></span><br><span class="line"> <span class="number">8</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isPs2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="number">9</span>         usb.isUsb();</span><br><span class="line"><span class="number">10</span>     &#125;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-策略模式"><a href="#5-策略模式" class="headerlink" title="5.策略模式"></a><strong>5.策略模式</strong></h3><p><strong>简介：</strong></p>
<p>将算法封装成一个个的类（即策略），在主程序中，根据传入的策略对象不同，调用不同的算法。</p>
<p><strong>实现：</strong></p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg" alt></p>
<ol>
<li><p>创建一个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Strategy.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建实现接口的实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//OperationAdd.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//OperationSubstract.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 - num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//OperationMultiply.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 * num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 <em>Context</em> 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Context.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <em>Context</em> 来查看当它改变策略 <em>Strategy</em> 时的行为变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StrategyPatternDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());    </span><br><span class="line">      System.out.println(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());      </span><br><span class="line">      System.out.println(<span class="string">"10 - 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">      context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());    </span><br><span class="line">      System.out.println(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">董兰天</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://DongLantian.github.io/2019/04/25/Java基础知识/">https://DongLantian.github.io/2019/04/25/Java基础知识/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://DongLantian.github.io">董兰天的江湖路</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/设计模式/">设计模式</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/25/Java虚拟机/"><i class="fa fa-chevron-left">  </i><span>Java虚拟机</span></a></div><div class="next-post pull-right"><a href="/2019/04/25/第一篇博客，测试一下/"><span>第一篇博客，测试一下</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(images\背景图片.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By 董兰天</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">董兰天的博客</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>